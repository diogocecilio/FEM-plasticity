(*Transforma tensor vetorial de voigth em tensor  3x3*)
FromVoigtToCart[
  sig_] := {{sig[[1]], sig[[6]], sig[[5]]}, {sig[[6]], sig[[2]], 
   sig[[4]]}, {sig[[5]], sig[[4]], sig[[3]]}}
(*Transforma tensor  3x3 em tensor vetorial de voigth *)
FromCartToVoigt[sig_] := {sig[[1, 1]], sig[[2, 2]], sig[[3, 3]], 
  sig[[2, 3]], sig[[1, 3]], sig[[1, 2]]}
FromCartToVoigt2[sig_] := {sig[[1, 1]], sig[[2, 2]], sig[[3, 3]], 
  2 sig[[2, 3]], 2 sig[[1, 3]], 2 sig[[1, 2]]}
ComputeS[m_] := Block[{cart, Sint},
  cart = FromVoigtToCart[m];
  Sint = cart - 1/3 Tr[cart] IdentityMatrix[3];
  FromCartToVoigt2[Sint]
  ]
ComputeJ2[m_] := Block[{cart, S},
  cart = FromVoigtToCart[m];
  S = cart - 1/3 Tr[cart] IdentityMatrix[3];
  1/2. Tr[S.S]
  ]
ComputeI1[m_] := Block[{cart, S},
  cart = FromVoigtToCart[m];
  N[Tr[cart]]
  ]
P = {{2/3, -1/3, -1/3, 0, 0, 0}, {-1/3, 2/3, -1/3, 0, 0, 
     0}, {-1/3, -1/3, 2/3, 0, 0, 0}, {0, 0, 0, 2, 0, 0}, {0, 0, 0, 0, 
     2, 0}, {0, 0, 0, 0, 0, 2}} // N;
ax[sigma_] := 
 A/3 {1, 1, 1, 0, 0, 0} + 
   1/(2 Sqrt[ComputeJ2[sigma]]) ComputeS[sigma] //. subst2
dadsigmax[sigma_] := 
 P 1/(2 Sqrt[ComputeJ2[sigma]]) - 
  1/(4 ComputeJ2[sigma]^(3/2)) Outer[Times, ComputeS[sigma], 
    ComputeS[sigma]]
(*Calcula autovalores e autovetores e ordena na ordem decrescente*)
EigenSystem[m_] := 
 Block[{epstprincipalvals, epstprincipaldir, orderedvalues, index, 
   oderedvectors, cart},
  cart = FromVoigtToCart[m];
  {epstprincipalvals, epstprincipaldir} = Eigensystem[cart // N];
  orderedvalues = Sort[epstprincipalvals, Greater];
  index = 
   DeleteDuplicates[
    Table[Position[epstprincipalvals, orderedvalues[[i]]], {i, 1, 
       3}] // Flatten];
  oderedvectors = Table[epstprincipaldir[[index[[i]]]], {i, 1, 3}];
  {orderedvalues, oderedvectors}
  ]
HW[{xi_, rho_, beta_}] := Block[{sig1, sig2, sig3},
   sig1 = xi /Sqrt[3] + Sqrt[2/3] rho Cos[beta];
   sig2 = xi/Sqrt[3] + Sqrt[2/3] rho Cos[beta - 2 Pi/3];
   sig3 = xi/Sqrt[3] + Sqrt[2/3] rho Cos[beta + 2 Pi/3];
   N[{sig1, sig2, sig3}]
   ];

F1HWCylDruckerPrager[{xi_, rho_, beta_}] := 
 Block[{xiint, rhoint, betaint, sigy, A, B, c},
  xiint = xi;
  rhoint = Sqrt[2] (B c - A xi);
  rhoint = Sqrt[2] B c - Sqrt[2/3] A xi;
  betaint = beta;
  N[{xiint, rhoint, betaint}]
  ]
FDP[I1_, J2_] := (Sqrt[J2] + A I1/3 - c B)
ApplyStrainComputeSigmaDep[epst_, epsp_, subst2_] := 
  Block[{invCe, R, Q, invQ, sig1, sig2, sig3, epse2D, sz, nu, ex, ey, 
    exy, sx, sy, tauxy, sigproj2D, Dep2D, sn1, pn1, updatedstress, II,
     eq, c , B, A, solgamma, full, dgamma, acone, yield, I1, J2, sol, 
    d, Dep, CT, T, epse, gamma, epsetrial, sigprojvoigth, proj, asol, 
    dadsigg, THWR, Rot, xitrial, xisol, xi, beta, rho, sigma, 
    rhotrial, Ce, pt, vec, betasol, young, G, K, epstint, epspint},
   
   Ce = N[{{(4 G)/3 + K, -((2 G)/3) + K, -((2 G)/3) + K, 0, 0, 
        0}, {-((2 G)/3) + K, (4 G)/3 + K, -((2 G)/3) + K, 0, 0, 
        0}, {-((2 G)/3) + K, -((2 G)/3) + K, (4 G)/3 + K, 0, 0, 
        0}, {0, 0, 0, G, 0, 0}, {0, 0, 0, 0, G, 0}, {0, 0, 0, 0, 0, 
        G}}] //. \!\(\*
TagBox["subst2",
Function[BoxForm`e$, 
MatrixForm[BoxForm`e$]]]\);
   invCe = 
    N[{{(G + 3 K)/(9 G K), -(1/(6 G)) + 1/(9 K), -(1/(6 G)) + 1/(9 K),
         0, 0, 0}, {-(1/(6 G)) + 1/(9 K), (G + 3 K)/(
        9 G K), -(1/(6 G)) + 1/(9 K), 0, 0, 
        0}, {-(1/(6 G)) + 1/(9 K), -(1/(6 G)) + 1/(9 K), (G + 3 K)/(
        9 G K), 0, 0, 0}, {0, 0, 0, 1/G, 0, 0}, {0, 0, 0, 0, 1/G, 
        0}, {0, 0, 0, 0, 0, 1/G}}] //. subst2;
   
   epstint = {epst[[1]], epst[[2]], 0, 0, 0, epst[[3]]} // N;
   epspint = {epsp[[1]], epsp[[2]], 0, 0, 0, epsp[[3]]} // N;
   
   epsetrial = (epstint - epspint);
   
   sigma = Ce.epsetrial;
   
   I1 = ComputeI1[sigma];
   J2 = ComputeJ2[sigma];
   yield = FDP[I1, J2] //. subst2;
   
   If[yield < 0,
    sigprojvoigth = sigma;
    epse = epsetrial;
    Dep = Ce;
    gamma = 0;
    ,
    
    xitrial = I1/Sqrt[3];
    rhotrial = Sqrt[2 J2];
    
    (*Auto valores em ordem decrescente*)
    {pt, vec} = EigenSystem[sigma] // N;
    
    betasol = 
     ArcTan[(Sqrt[3] (-sig2 + sig3))/(-2 sig1 + sig2 + sig3)] //. 
       subst2 /. {sig1 -> pt[[1]], sig2 -> pt[[2]], sig3 -> pt[[3]]};
    xisol = 
     1/(6 (G + A^2 K)) (-3 A K (2 sig1 - sig2 - sig3) Cos[betasol] + 
          Sqrt[3] (6 A B c K + 2 G (sig1 + sig2 + sig3) - 
             3 A K (sig2 - sig3) Sin[betasol])) //. 
       subst2 /. {sig1 -> pt[[1]], sig2 -> pt[[2]], sig3 -> pt[[3]]};
    proj = HW[F1HWCylDruckerPrager[{xisol, rho, betasol}]] //. subst2;
    sigprojvoigth = 
     FromCartToVoigt[
      Sum[proj[[i]] Outer[Times, vec[[i]], vec[[i]]], {i, 1, 3}]];
    asol = ax[sigprojvoigth] //. subst2;
    dadsigg = dadsigmax[sigprojvoigth] //. subst2;
    epse = invCe.sigprojvoigth;
    gamma = Norm[epsetrial - epse]/Norm[asol];
    
    dadsigg = dadsigmax[sigma] //. subst2;
    CT = Ce.((IdentityMatrix[
          6] - (Outer[Times, asol, asol].Ce)/(asol.Ce.asol)));
    T = (IdentityMatrix[6] - gamma dadsigg.Ce );
    Dep = CT.T;
    
    acone = Sqrt[J2] - gamma G //. subst2;
    
    If[acone < 0,
     
     (*Print["acone = ",acone];*)
     II = {1, 1, 1, 0, 0, 0};
      eq = (c B/A - I1/3 + K dgamma A) //. subst2;
     solgamma = NSolve[eq == 0, dgamma][[1, 1, 2]];
     Dep = 0 Outer[Times, II, II];
     full = FromVoigtToCart[sigma];
     
     If[J2 <= 0,
      (*no caso de tracao hidrostatica j2 = 0 *)
      sn1 = 0;
      ,
      sn1 = (1 - G solgamma/Sqrt[J2]) (full - 
            1/3 Tr[full] IdentityMatrix[3]) //. subst2;
      ];
     
     pn1 = I1/3 - K A solgamma //. subst2;
     updatedstress = sn1 + pn1 IdentityMatrix[3];
     sigprojvoigth = FromCartToVoigt[updatedstress];
     epse = invCe.sigprojvoigth;
     gamma = solgamma;
     ];
    ];
   Dep2D = {{Dep[[1, 1]], Dep[[1, 2]], Dep[[1, 6]]}, {Dep[[2, 1]], 
      Dep[[2, 2]], Dep[[2, 6]]}, {Dep[[6, 1]], Dep[[6, 2]], 
      Dep[[6, 6]]}};
   sigproj2D = {sigprojvoigth[[1]], sigprojvoigth[[2]], 
     sigprojvoigth[[6]]};
   {sx, sy, tauxy} = sigproj2D;
   sz = nu (sx + sy);
   ex = 1/young (sx - nu (sy + sz));
   ey = 1/young (sy - nu (sx + sz));
   exy = tauxy/(G);
   epse2D = {ex, ey, exy};
   {sigproj2D, Dep2D, epse2D, gamma} //. subst2
   
   ];
(*Compute2DShape*)
Compute2DShape[order_, eltype_] := 
  Block[{zeta1, zeta2, zeta3, a, b, xi, eta, psis, dpsis},
   If[serendipity == True,
    psis = {
       (1 - xi) (1 - eta) (-xi - eta - 1)/
         4,(*1*)(1 + xi) (1 - eta) (xi - eta - 1)/
         4,(*2*)(1 + xi) (1 + eta) (xi + eta - 1)/
         4,(*3*)(1 - xi) (1 + eta) (-xi + eta - 1)/4,(*4*)
       (1 - xi^2) (1 - eta)/2,(*5*)(1 + xi) (1 - eta^2)/
         2,(*6*)(1 - xi^2) (1 + eta)/2,(*7*)(1 - xi) (1 - eta^2)/
         2(*8*)
       };
    ,
    psis = {
       xi eta (xi - 1) (eta - 1)/4, xi eta (xi + 1) (eta - 1)/4, 
       xi eta (xi + 1) (eta + 1)/4, 
       xi eta (xi - 1) (eta + 1)/4, -eta (xi + 1) (xi - 1) (eta - 1)/2,
       -xi (xi + 1) (eta + 1) (eta - 1)/
         2, -eta (xi + 1) (xi - 1) (eta + 1)/
         2, -xi (xi - 1) (eta + 1) (eta - 1)/
         2, (xi + 1) (xi - 1) (eta + 1) (eta - 1)
       };
    ];
   dpsis = 
    Transpose[
     Table[{D[psis[[i]], xi], D[psis[[i]], eta]}, {i, 1, 
       Length[psis]}]];
   {psis, dpsis}
   ];
(****************************************************************************************)\

(*IntegrationRule*)
<< NumericalDifferentialEquationAnalysis`
IntegrationRule[porder_, eltype_] := Block[{pts, w, npts, matpsts},
   {pts, w} = Transpose[GaussianQuadratureWeights[porder + 2, -1, 1]];
   npts = Length[pts];
   matpsts = 
    Flatten[Table[{pts[[j]], pts[[i]], w[[j]] w[[i]]}, {i, npts, 
       1, -1}, {j, 1, npts}], 1];
   N[matpsts]
   ];
(****************************************************************************************)\

(*CalcStiff*)
Assemble[allcoords_, nnodes_, topol_, order_, eltype_, 
   displacement_] := 
  Block[{nels, rows, sz, cols, Kglob, Fglob, co, Ke, Fe, fu, rowglob, 
    colglob, uglob, Fe2, Fglob2},
   nels = Length[allcoords];
   rows = Length[allcoords[[1]]];
   sz = 2 Length[nnodes];
   cols = rows;
   Kglob = Table[0, {sz}, {sz}];
   Fglob = Table[0, {sz}];
   Fglob2 = Table[0, {sz}];
   uglob = 
    Table[Table[{displacement[[2 topol[[k, j]] - 1]], 
       displacement[[2 topol[[k, j]] ]]}, {j, 1, 
       Length[topol[[k]]]}], {k, 1, nels}];
   
   Table[
    co = allcoords[[k]] // N;
    {Ke, Fe, Fe2} = CalcStiff[order, co, eltype, uglob[[k]]];
    fu = -1;
    Table[
     rowglob = topol[[k, i]];
     Table[
      colglob = topol[[k, j]];
      Kglob[[2 rowglob + fu, 2 colglob + fu]] += 
       Ke[[2 i + fu, 2 j + fu]];
      Kglob[[2 rowglob + fu, 2 colglob + 1 + fu]] += 
       Ke[[2 i + fu, 2 j + 1 + fu]];
      Kglob[[2 rowglob + 1 + fu, 2 colglob + fu]] += 
       Ke[[2 i + 1 + fu, 2 j + fu]];
      Kglob[[2 rowglob + 1 + fu, 2 colglob + 1 + fu]] += 
       Ke[[2 i + 1 + fu, 2 j + 1 + fu]];, {j, 1, cols}];
     Fglob[[2 rowglob + fu]] += Fe[[2 i + fu]];
     Fglob[[2 rowglob]] += Fe[[2 i]];
     Fglob2[[2 rowglob + fu]] += Fe2[[2 i + fu]];
     Fglob2[[2 rowglob]] += Fe2[[2 i]];
     , {i, 1, rows}];
    , {k, 1, nels}];
   
   {Kglob, Fglob, Fglob2}
   ];
(*Compute one dimension shape functions*)
ComputeShape[order_, var_, x0_, xf_] := Block[{npoints},
  npoints = order + 1;
  tab3[i_, n_] := Table[If[j == i, 1, 0], {j, 1, n}];
  poli3[j_, n_] := 
   Table[{x0 + (xf - x0) (i - 1)/(n - 1), tab3[j, n][[i]]}, {i, 1, n}];
  ListPoli[n_] := 
   Table[InterpolatingPolynomial[poli3[i, n], var], {i, 1, n}];
  ListPoli[npoints]
  ]
(*Find node id*)
FindIds[nodes_, coords_] := 
  Block[{nodestofind = Nearest[nodes, coords][[All, 1]]}, 
   Flatten[Position[nodes, Alternatives @@ nodestofind]]];
(*Find node id*)
LineTopology[ids_, order_] := Block[{k, vg, v, j, i},
   k = 0;
   vg = {};
   For[j = 1, j < Length[ids]/(order), j++,
    v = {};
    For[i = 1, i <= order + 1, i++,
     AppendTo[v, ids[[i + k]]];
     ];
    AppendTo[vg, v];
    k += order;
    ];
   vg
   ];
ContributeLineDirichlet[EK_, EF_, ids_, {dir_, val_}] := 
  Block[{nodes, i, j, k, Ek = EK, Ef = EF},
   nodes = Length[ids];
   For[i = 1, i <= nodes, i++,
    If[dir == 1,
      For[j = 1, j <= Length[Ek], j++,
       Ek[[2 ids[[i]] - 1, j]] = 0;
       Ek[[j, 2 ids[[i]] - 1]] = 0;
       ];
      Ek[[2 ids[[i]] - 1, 2 ids[[i]] - 1]] = 1;
      Ef[[2 ids[[i]] - 1]] = val;
      ,
      For[j = 1, j <= Length[Ek], j++,
       Ek[[2 ids[[i]], j]] = 0;
       Ek[[j, 2 ids[[i]]]] = 0;
       ];
      Ek[[2 ids[[i]], 2 ids[[i]]]] = 1;
      Ef[[2 ids[[i]]]] = val;
      ];
    ];
   {Ek, Ef}
   ];
ContributeStraigthLineNewman[nodes_, order_, ids_, normal_, f_] := 
  Block[{vecint, Ef, top, i, pt, xf, x, shapes, integral, deltas, 
    lengths},
   vecint = {};
   Ef = Table[0, {Length[nodes] 2}];
   top = LineTopology[ids, order];
   deltas = 
    Table[Table[
      Norm[nodes[[top[[i, j]]]] - nodes[[top[[i, j + 1]]]]], {j, 1, 
       order}], {i, 1, Length[top]}];
   If[order > 1,
    lengths = 
      Table[deltas[[i, j]] + deltas[[i, j + 1]], {j, 1, 
         order - 1}, {i, 1, Length[deltas]}][[1]];
    ,
    lengths = Flatten[deltas, 1];
    ];
   For[i = 1, i <= Length[lengths], i++,
    xf = lengths[[i]];
    shapes = ComputeShape[order, x, 0, xf];
    integral = 
     Table[Integrate[shapes[[i]] f[x], {x, 0, xf}], {i, 1, 
       Length[shapes]}];
    Table[
     pt = nodes[[top[[i, j]]]];
     Ef[[top[[i, j]] 2 - 1]] += integral[[j]] normal[[1]];
     Ef[[top[[i, j]] 2]] += integral[[j]] normal[[2]];
     ,
     {j, 1, order + 1}
     ];
    ];
   Ef
   ];

CoumpteStrain[gradprevsol_] := 
 Block[{dudx, dudy, dvdx, dvdy, gradu, strain, ex, ey, exy, ux, uy, 
   kk},
  {{dudx, dudy}, {dvdx, dvdy}} = gradprevsol;
  ex = dudx;
  ey = dvdy;
  exy = (dudy + dvdx);
  {ex, ey, exy}
  ]

(*Compute the integration point contribution of the integral*)
Contribute[data_] := 
  Block[{NShapes, gamma, psis, GradPsi, Jac, x, y, nnodes, GradPhi, 
    DetJ, InvJac, BB, C, ek, ef, elcoords, weight, stress, Dep, 
    eldisplacement, gradu, epst, epsp, epse, epspeint, ef2},
   {psis, GradPsi, elcoords, weight, eldisplacement} = data;
   {x, y} = psis.elcoords;
   Jac = GradPsi.elcoords;
   nnodes = Length[psis];
   DetJ = Det[Jac];
   InvJac = Inverse[Jac];
   GradPhi = InvJac.GradPsi;
   BB = {Flatten[Table[{GradPhi[[1, i]], 0}, {i, 1, nnodes}], 1], 
     Flatten[Table[{0, GradPhi[[2, i]]}, {i, 1, nnodes}], 1], 
     Flatten[Table[{GradPhi[[2, i]], GradPhi[[1, i]]}, {i, 1, 
        nnodes}], 1]};
   NShapes = {Flatten[Table[{psis[[i]], 0}, {i, 1, Length[psis]}], 1],
      Flatten[Table[{0, psis[[i]]}, {i, 1, Length[psis]}], 1]};
   (*Displacement gradient*)
   gradu = GradPhi.eldisplacement;
   (*Infinitesimal Strain Tensor*)
   epst = CoumpteStrain[gradu];
   (* globalcounter =  integration point index mesh identifier. 
   It has the size of the integration points rule multiplied by the \
number of mesh elements.*)
   (* Plastic strain vector in the last converged step. 
   This vector is updated when the newton method converge.  If[
   Converge=True, epspsolitern = epspvec] *)
   epsp = epspsolitern[[globalcounter]];
   (*Integration of the elastoplastic equations*)
   {stress, Dep, epse, gamma} = 
    ApplyStrainComputeSigmaDep[epst, epsp, subst2];
   epspeint = epst - epse;
   (*Store the plastic strain at the current integration point. 
   When newton's method converge the values are transfered to \
epspsolitern=epspvec. *)
   epspvec[[globalcounter]] = epspeint;
   globalcounter++;
   AppendTo[epsppost, {x, y, epspeint}];
   AppendTo[stressppost, {x, y, stress}];
   AppendTo[dgamma, {x, y, gamma}];
   (*Element Stiffness Matrix contribution*)
   ek = (Transpose[BB].Dep.BB) weight DetJ;
   (*Element Internal force vector contribution*)
   ef = (Transpose[BB].stress) weight DetJ;
   ef2 = (Transpose[NShapes].{0, -bodyforce}) weight DetJ;
   {ek, ef, ef2}
   ];

(*CalcStiff - Assemble the element stiffness matrix and internal \
force vectors*)
CalcStiff[order_, elcoords_, eltype_, eldisplacement_] := 
  Block[{ef2, nnodes, ek, ef, intrule, psis, GradPsi, xi, eta, data, 
    w, npts},
   
   nnodes = Length[elcoords];
   ek = Table[0, {nnodes 2}, {nnodes 2}];
   ef = Table[0, {nnodes 2}];
   ef2 = Table[0, {nnodes 2}];
   intrule = IntegrationRule[order, eltype];
   {psis, GradPsi} = Compute2DShape[order, eltype];
   npts = Length[intrule];
   Table[
    {xi, eta, w} = intrule[[i]];
    data = {psis, GradPsi, elcoords, w, eldisplacement};
    {ek, ef, ef2} += Contribute[data];
    , {i, 1, npts}
    ];
   {ek, ef, ef2}
   ];

ComputeSolNoInterpolation[topol_, coords_, order_, coefs_, eltype_, 
  scale_] := 
 Block[{elvecnorm, diplacenormvec, cx, cy, ux, uy, , displacevec, 
   elvec, X, InvJ, GradPhi, GradPsi, nels, dsol, xa, xb, k = 0, i, 
   phi, sol, phisz, j, xx, J, co, h, x = 0, psis, id, y = 0, xi, eta, 
   Jac, DetJac, kk},
  {psis, GradPsi} = Compute2DShape[order, eltype];
  nels = Length[topol];
  displacevec = {};
  diplacenormvec = {};
  Table[
   elvec = {};
   (*elvecnorm={};*)
   x = 0.;
   y = 0.;
   kk = Length[psis];
   Table[
    id = topol[[i, j]];
    cx = coords[[id, 1]] ;
    cy = coords[[id, 2]] ;
    ux = scale coefs[[2 id - 1]] ;
     uy = scale coefs[[2 id]] ;
    AppendTo[elvec, {{cx, cy}, {ux + cx, uy + cy}}];
    AppendTo[diplacenormvec, {cx, cy, Norm[{ux/scale, uy/scale}]}];
    , {j, 1, kk}];
   AppendTo[displacevec, elvec];
   (*AppendTo[diplacenormvec,elvec];*)
   , {i, 1, nels}];
  {displacevec, diplacenormvec}
  ]

pack = Developer`ToPackedArray;

(*topol=pack@Transpose@Drop[Transpose@Import["https://www.dropbox.com/\
s/setx566dvgx3urx/mesh-els-strip-foot-structured4.txt?dl=1","Table"],\
1];
nnodesAll=Import["https://www.dropbox.com/s/mxelbdwug4yv3lr/mesh-\
nodes-strip-foot-structured4.txt?dl=1","Table"];*)
topol = pack@
   Transpose@
    Drop[Transpose@
      Import["https://www.dropbox.com/s/vtk5ybrgg69nl79/mesh-els-\
strip-foot-structured.txt?dl=1", "Table"], 1];
nnodesAll = 
  Import["https://www.dropbox.com/s/xu5f15vm4k0kmi1/mesh-nodes-strip-\
foot-structured.txt?dl=1", "Table"];

nnodes = pack@N[nnodesAll[[All, {2, 3}]]];
allcoords = 
  Table[nnodes[[topol[[i]][[j]]]], {i, 1, Length[topol]}, {j, 1, 8}];
(*edges are straight*)
meshVis1 = 
  Graphics[{FaceForm[], EdgeForm[Dashing[Tiny]], 
    GraphicsComplex[nnodes, Polygon[topol[[All, {1, 2, 3, 4}]]]]}];
meshVis1 = 
  Graphics[{FaceForm[], EdgeForm[Black], 
    GraphicsComplex[nnodes, Polygon[topol[[All, {1, 2, 3, 4}]]]]}];
nodeVis = 
  Graphics[{PointSize[Medium], Black, 
    MapIndexed[Text[#2[[1]], #1, {-1, 1}] &, nnodes], {Black, 
     Point[nnodes]}}];
nodeVis = Graphics[{PointSize[Medium], Black, {Black, Point[nnodes]}}];
Show[meshVis1];
el = 120;
nodeel = Table[nnodes[[topol[[el]][[i]]]], {i, 1, Length[topol[[el]]]}]
nodeVis = Graphics[{PointSize[Medium], Black, {Black, Point[nodeel]}}];
Show[meshVis1, nodeVis]
order = 2
serendipity = False;

a = 500;
b2 = 50;
x0 = 0.; xf = a;
y0 = 0; yf = 0;
ndivs = 10000;
searchpathinferiorline = 
  Flatten[Table[{x, y}, {x, x0, xf, (xf - x0)/ndivs}, {y, y0, 
     yf, (yf - y0)/ndivs}], 1];
x0 = 0; xf = 0.;
y0 = 0; yf = a;
searchpathleftline = Table[{x0, y}, {y, y0, yf, (yf - y0)/ndivs}];
x0 = 0; xf = b2;
y0 = a; yf = a;
searchpathupline = Table[{x, y0}, {x, x0, xf, (xf - x0)/ndivs}];
x0 = a; xf = a;
y0 = 0; yf = a;
searchpathrigthline = Table[{x0, y}, {y, y0, yf, (yf - y0)/ndivs}];
idsinferior = FindIds[nnodes, searchpathinferiorline]
idsleft = FindIds[nnodes, searchpathleftline]
idssup = FindIds[nnodes, searchpathupline]
idsrigth = FindIds[nnodes, searchpathrigthline]

planestress = False;
serendipity = True;
bodyforce = 0;
order = 2;
eltype = 1;


subst2 = {c -> 490., phi -> 20/180. Pi, young -> 10^7. (*kPa*), 
   nu -> 0.48 , G -> young/(2 (1 + nu)), K -> (young)/(3 (1 - 2 nu)), 
   A -> 3 Tan[phi]/Sqrt[9 + 12 Tan[phi]^2],
   B -> 3 /Sqrt[9 + 12 Tan[phi]^2]};


f[x_] := 15 c //. subst2 ;
FEXT = ContributeStraigthLineNewman[nnodes, order, idssup, {0, -1}, f];


globalcounter = 1;
intrule = IntegrationRule[order, eltype];
npts = Length[intrule]; 
nglobalpts = Length[topol] npts;
epspvec = Table[0, {nglobalpts}, {3}];
epspsolitern = Table[0, {nglobalpts}, {3}];

solss = {};
sol2 = {{0, 0}};
sol3 = {};
displace = Table[0, {Length[nnodes] 2}];
AppendTo[solss, displace];
epspsolu = {};
stresssolu = {};
dgammasol = {};

lamb = 1;
diff = 10;
l = 0.25;
counterout = 1;
tol1 = 10^-3;
tol2 = 10^-5;
While[Abs[diff] > tol1 && counterout <= 60,
 
 Print["i = ", counterout, " | lamb = ", lamb, " | lambn = ", lambn, 
  " | diff = ", diff];
 counter = 1;
 err1 = 10;
 err2 = 10;
 
 dw = Table[0, {Length[nnodes] 2}];
 
 lambn = lamb;
 While[counter <= 30 && err2 > tol2,
  
  epsppost = {};
  dgamma = {};
  stressppost = {};
  globalcounter = 1;
  {KT, FINT, FEXTB} = 
   Assemble[allcoords, nnodes, topol, order, eltype, displace];
  FEXT += FEXTB;
  imposex = 1;
  imposey = 2;
  
  R = lamb  FEXT - FINT;
  
  {KT, R} = ContributeLineDirichlet[KT, R, idsinferior, {imposey, 0}];
  {KT, R} = ContributeLineDirichlet[KT, R, idsleft, {imposex, 0}];
  {KT, R} = ContributeLineDirichlet[KT, R, idsrigth, {imposex, 0}];
  
  dws = LinearSolve[KT, R, Method -> "Banded"];
  dwb = LinearSolve[KT, FEXT, Method -> "Banded"];
  a = dwb.dwb;
  b = 2 (dw + dws).dwb;
  ccc = (dw + dws).(dw + dws) - l^2;
  dlamb = Solve[a x^2 + b x + ccc == 0, x][[2, 1, 2]];
  dww = dws + dlamb dwb;
  dw += dww;
  lamb += dlamb;
  (*dw=LinearSolve[KT,R];*)
  res = Norm[dww];
  displace += dww;
  err1 = Norm[R]/Norm[lamb  FEXT];
  (*If[err1>temp && counter>4,diverge=True];*)
  temp = err1;
  err2 = Norm[dww]/Norm[displace];
  
  Print["Iteration number = " , counter, "  |R|/|FE| =  ", 
   Norm[R]/Norm[lamb FEXT], "  |\[CapitalDelta]u|/|u| = ", 
   Norm[dww]/Norm[displace], "  |R| =  ", Norm[R] , " |dw| = ", 
   Norm[dww], " | dlamb = ", dlamb, " | lamb = ", lamb];
  counter++;
  ];
 diff = Abs[lamb - lambn];
 AppendTo[stresssolu, stressppost];
 AppendTo[epspsolu, epsppost];
 AppendTo[solss, displace];
 id = FindIds[nnodes, {{0, 500}}][[1]];
 AppendTo[sol2, {-displace[[id 2]]/100, f[x] lamb/c //. subst2}];
 
 AppendTo[sol3, epspvec];
 (*Atualiza variável de estado plástica no passo convergido*)
 epspsolitern = epspvec;
 counterout++;
 ]

solu = 13;
Show[ListPlot[sol2, AspectRatio -> 1, PlotMarkers -> {Automatic, 10}],
  Plot[15., {x, 0, 0.004}], PlotRange -> {{0, 0.004}, {0, 20}}]
sol = solss[[solu]];
scale = 200;
deformed = (Flatten[nnodes] + scale sol);
tabdeformed = 
  Table[{deformed[[i]], deformed[[i + 1]]}, {i, 1, Length[deformed], 
    2}];
g = Show[meshVis1, 
  Graphics[{FaceForm[], EdgeForm[Black], 
    GraphicsComplex[tabdeformed, 
     Polygon[topol[[All, {1, 2, 3, 4}]]]]}]]


{vecs2, vecs3} = 
  ComputeSolNoInterpolation[topol, nnodes, order, sol, eltype, scale];
arrows = Table[
   Graphics[{Arrowheads[.02], 
     Arrow[{vecs2[[el]][[i]][[1]], vecs2[[el]][[i]][[2]]}]}], {el, 1, 
    Length[vecs2]}, {i, 1, Length[vecs2[[el]]]}];
sh = Show[meshVis1, arrows, PlotRange -> All]

pack = Developer`ToPackedArray;
topol = pack@
   Transpose@
    Drop[Transpose@
      Import["https://www.dropbox.com/s/pyio7qkv52a6n60/mesh-talude-\
els.txt?dl=1", "Table"], 1];
nnodesAll = 
  Import["https://www.dropbox.com/s/wkcyf51o1wppmpx/mesh-talude-nodes.\
txt?dl=1", "Table"];
nnodes = pack@N[nnodesAll[[All, {2, 3}]]];
allcoords = 
  Table[nnodes[[topol[[i]][[j]]]], {i, 1, Length[topol]}, {j, 1, 8}];
(*edges are straight*)
meshVis1 = 
  Graphics[{FaceForm[], EdgeForm[Dashing[Tiny]], 
    GraphicsComplex[nnodes, Polygon[topol[[All, {1, 2, 3, 4}]]]]}];

meshVis2 = 
  Graphics[{FaceForm[], EdgeForm[Black], 
    GraphicsComplex[nnodes, Polygon[topol[[All, {1, 2, 3, 4}]]]]}];
nodeVis = 
  Graphics[{PointSize[Medium], Black, 
    MapIndexed[Text[#2[[1]], #1, {-1, 1}] &, nnodes], {Black, 
     Point[nnodes]}}];
meshVis1 = 
  Graphics[{FaceForm[], EdgeForm[Dashing[Tiny]], 
    GraphicsComplex[nnodes, Polygon[topol[[All, {1, 2, 3, 4}]]]]}];
meshVis1 = 
  Graphics[{FaceForm[], EdgeForm[Black], 
    GraphicsComplex[nnodes, Polygon[topol[[All, {1, 2, 3, 4}]]]]}];
nodeVis = 
  Graphics[{PointSize[Medium], Black, 
    MapIndexed[Text[#2[[1]], #1, {-1, 1}] &, nnodes], {Black, 
     Point[nnodes]}}];
el = 1;
nodeel = Table[nnodes[[topol[[el]][[i]]]], {i, 1, Length[topol[[el]]]}]
nodeVis = Graphics[{PointSize[Medium], Black, {Black, Point[nodeel]}}];
Show[meshVis1, nodeVis]

order = 2
serendipity = True;

x0 = 0.; xf = 75;
y0 = 0; yf = 0;
ndivs = 10000;
searchpathinferiorline = 
  Flatten[Table[{x, y}, {x, x0, xf, (xf - x0)/ndivs}, {y, y0, 
     yf, (yf - y0)/ndivs}], 1];
x0 = 0; xf = 0.;
y0 = 0; yf = 40;
searchpathleftline = Table[{x0, y}, {y, y0, yf, (yf - y0)/ndivs}];
x0 = 75; xf = 75;
y0 = 0; yf = 30;
searchpathrigthline = Table[{x0, y}, {y, y0, yf, (yf - y0)/ndivs}];
idsinferior = FindIds[nnodes, searchpathinferiorline]
idsleft = FindIds[nnodes, searchpathleftline]
idsrigth = FindIds[nnodes, searchpathrigthline]

planestress = False;
serendipity = True;
bodyforce = 0;
order = 2;
eltype = 1;


subst2 = {c -> 50., phi -> 20/180. Pi, young -> 20000. (*kPa*), 
   nu -> 0.49, G -> young/(2 (1 + nu)), K -> (young)/(3 (1 - 2 nu)), 
   A -> 3 Tan[phi]/Sqrt[9 + 12 Tan[phi]^2],
   B -> 3 /Sqrt[9 + 12 Tan[phi]^2]};


f[x_] := 0;
(*FEXT=ContributeStraigthLineNewman[nnodes,order,idssup,{0,-1},f];*)
bodyforce = 20;


globalcounter = 1;
intrule = IntegrationRule[order, eltype];
npts = Length[intrule]; 
nglobalpts = Length[topol] npts;
epspvec = Table[0, {nglobalpts}, {3}];
epspsolitern = Table[0, {nglobalpts}, {3}];

solss = {};
sol2 = {{0, 0}};
sol3 = {};
displace = Table[0, {Length[nnodes] 2}];
AppendTo[solss, displace];
epspsolu = {};
stresssolu = {};
dgammasol = {};
soltalude = {};
lamb = 1;
diff = 10;
l0 = 0.8;
l = l0
niterdesired = 5;
counterout = 1;
tol1 = 10^-6;
tol2 = 10^-6;
While[Abs[diff] > tol1 && counterout <= 80,
 
 Print["i = ", counterout, " | lamb = ", lamb, " | lambn = ", lambn, 
  " | diff = ", diff];
 counter = 1;
 err1 = 10;
 err2 = 10;
 
 dw = Table[0, {Length[nnodes] 2}];
 
 lambn = lamb;
 While[counter <= 50 && err2 > tol2,
  
  epsppost = {};
  dgamma = {};
  stressppost = {};
  globalcounter = 1;
  {KT, FINT, FEXTB} = 
   Assemble[allcoords, nnodes, topol, order, eltype, displace];
  FEXT = FEXTB;
  imposex = 1;
  imposey = 2;
  R = lamb  FEXT - FINT;
  {KT, R} = ContributeLineDirichlet[KT, R, idsinferior, {imposey, 0}];
  {KT, R} = ContributeLineDirichlet[KT, R, idsleft, {imposex, 0}];
  {KT, R} = ContributeLineDirichlet[KT, R, idsrigth, {imposex, 0}];
  
  {KT, FEXT} = 
   ContributeLineDirichlet[KT, FEXT, idsinferior, {imposey, 0}];
  {KT, FEXT} = 
   ContributeLineDirichlet[KT, FEXT, idsleft, {imposex, 0}];
  {KT, FEXT} = 
   ContributeLineDirichlet[KT, FEXT, idsrigth, {imposex, 0}];
  
  dws = LinearSolve[KT, R, Method -> "Banded"];
  dwb = LinearSolve[KT, FEXT, Method -> "Banded"];;
  aa = dwb.dwb;
  bb = 2 (dw + dws).dwb;
  ccc = (dw + dws).(dw + dws) - l^2;
  (*Print["a = ",aa];
  Print["b = ",bb];
  Print["c = ",ccc];*)
  dlamb = Solve[aa x^2 + bb x + ccc == 0, x][[2, 1, 2]];
  dww = dws + dlamb dwb;
  dw += dww;
  lamb += dlamb;
  (*dw=LinearSolve[KT,R];*)
  res = Norm[dww];
  displace += dww;
  err1 = Norm[R]/Norm[lamb  FEXT];
  (*If[err1>temp && counter>4,diverge=True];*)
  temp = err1;
  err2 = Norm[dww]/Norm[displace];
  
  Print["Iteration number = " , counter, "  |R|/|FE| =  ", 
   Norm[R]/Norm[lamb FEXT], "  |\[CapitalDelta]u|/|u| = ", 
   Norm[dww]/Norm[displace], "  |R| =  ", Norm[R] , " |dw| = ", 
   Norm[dww], " | dlamb = ", dlamb, " | lamb = ", lamb, 
   " | bodyforce lamb = ", bodyforce lamb];
  counter++;
  ];
 diff = Abs[lamb - lambn];
 Print["l = ", l];
 AppendTo[stresssolu, stressppost];
 AppendTo[dgammasol, dgamma];
 AppendTo[epspsolu, epsppost];
 AppendTo[solss, displace];
 id = FindIds[nnodes, {{35, 40}}][[1]];
 AppendTo[soltalude, {-displace[[id 2]], lamb}];
 AppendTo[sol3, epspvec];
 
 (*Atualiza variável de estado plástica no passo convergido*)
 epspsolitern = epspvec;
 counterout++;
 ]

sol = solss[[4]];
scale = 5;
deformed = (Flatten[nnodes] + scale sol);
tabdeformed = 
  Table[{deformed[[i]], deformed[[i + 1]]}, {i, 1, Length[deformed], 
    2}];
g = Show[meshVis1, 
  Graphics[{FaceForm[], EdgeForm[Black], 
    GraphicsComplex[tabdeformed, 
     Polygon[topol[[All, {1, 2, 3, 4}]]]]}]]

Show[ListLinePlot[soltalude, AspectRatio -> 1, 
  PlotMarkers -> {Automatic, 10}], Plot[4.045, {x, 0, 1.07}], 
 PlotRange -> {{0, 1.07}, {0, 5}}]

gph = Graphics[{White, 
    Polygon[{{35, 40}, {45, 30}, {75, 30}, {75, 40}}]}];
{vecs2, vecs3} = 
  ComputeSolNoInterpolation[topol, nnodes, order, sol, eltype, scale];
arrows = Table[
   Graphics[{Opacity[0.8], Black, Arrowheads[.012], 
     Arrow[{vecs2[[el]][[i]][[1]], vecs2[[el]][[i]][[2]]}]}], {el, 1, 
    Length[vecs2]}, {i, 1, Length[vecs2[[el]]]}];
teste1 = Table[{dgammasol[[25]][[i]][[1]], dgammasol[[25]][[i]][[2]], 
    dgammasol[[25]][[i]][[3]]}, {i, 1, Length[dgammasol[[25]]]}];
Show[ListContourPlot[teste1, 
  PlotLegends -> {Placed[Automatic, {Left, Center}]}], gph, meshVis2, 
 PlotRange -> All, AspectRatio -> Automatic, Frame -> False]
sh = Show[meshVis1, arrows, PlotRange -> All]