(*Transforma tensor vetorial de voigth em tensor  3x3*)
FromVoigtToCart[
  sig_] := {{sig[[1]], sig[[6]], sig[[5]]}, {sig[[6]], sig[[2]], 
   sig[[4]]}, {sig[[5]], sig[[4]], sig[[3]]}}
(*Transforma tensor  3x3 em tensor vetorial de voigth *)
FromCartToVoigt[sig_] := {sig[[1, 1]], sig[[2, 2]], sig[[3, 3]], 
  sig[[2, 3]], sig[[1, 3]], sig[[1, 2]]}
FromCartToVoigt2[sig_] := {sig[[1, 1]], sig[[2, 2]], sig[[3, 3]], 
  2 sig[[2, 3]], 2 sig[[1, 3]], 2 sig[[1, 2]]}
ComputeS[m_] := Block[{cart, Sint},
  cart = FromVoigtToCart[m];
  Sint = cart - 1/3 Tr[cart] IdentityMatrix[3];
  FromCartToVoigt2[Sint]
  ]
ComputeJ2[m_] := Block[{cart, S},
  cart = FromVoigtToCart[m];
  S = cart - 1/3 Tr[cart] IdentityMatrix[3];
  1/2. Tr[S.S]
  ]
ComputeI1[m_] := Block[{cart, S},
  cart = FromVoigtToCart[m];
  N[Tr[cart]]
  ]
P = {{2/3, -1/3, -1/3, 0, 0, 0}, {-1/3, 2/3, -1/3, 0, 0, 
    0}, {-1/3, -1/3, 2/3, 0, 0, 0}, {0, 0, 0, 2, 0, 0}, {0, 0, 0, 0, 
    2, 0}, {0, 0, 0, 0, 0, 2}};
ax[sigma_] := Sqrt[3]/(2 Sqrt[ComputeJ2[sigma]]) ComputeS[sigma]
dadsigmax[sigma_] := 
 P Sqrt[3]/(2 Sqrt[ComputeJ2[sigma]]) - 
  Sqrt[3]/(4 ComputeJ2[sigma]^(3/2)) Outer[Times, ComputeS[sigma], 
    ComputeS[sigma]]
(*Calcula autovalores e autovetores e ordena na ordem decrescente*)
EigenSystem[m_] := 
 Block[{epstprincipalvals, epstprincipaldir, orderedvalues, index, 
   oderedvectors, cart},
  cart = FromVoigtToCart[m];
  {epstprincipalvals, epstprincipaldir} = Eigensystem[cart // N];
  orderedvalues = Sort[epstprincipalvals, Greater];
  index = 
   DeleteDuplicates[
    Table[Position[epstprincipalvals, orderedvalues[[i]]], {i, 1, 
       3}] // Flatten];
  oderedvectors = Table[epstprincipaldir[[index[[i]]]], {i, 1, 3}];
  {orderedvalues, oderedvectors}
  ]
HW[{xi_, rho_, beta_}] := Block[{sig1, sig2, sig3},
   sig1 = xi /Sqrt[3] + Sqrt[2/3] rho Cos[beta];
   sig2 = xi/Sqrt[3] + Sqrt[2/3] rho Cos[beta - 2 Pi/3];
   sig3 = xi/Sqrt[3] + Sqrt[2/3] rho Cos[beta + 2 Pi/3];
   N[{sig1, sig2, sig3}]
   ];
F1HWCylVonMises[{xi_, rho_, beta_}] := 
 Block[{xiint, rhoint, betaint, sigy},
  xiint = xi;
  rhoint = Sqrt[2/3] sigy;
  betaint = beta;
  {xiint, rhoint, betaint}
  ]
FDP[I1_, J2_] := Sqrt[3 J2] - sigy;
ApplyStrainComputeSigmaDep[epst_, epsp_, subst2_] := 
  Block[{invCe, R, Q, invQ, sig1, sig2, sig3, epse2D, sz, nu, ex, ey, 
    exy, sx, sy, tauxy, sigproj2D, Dep2D, sn1, pn1, updatedstress, II,
     eq, c , B, A, solgamma, full, dgamma, acone, yield, I1, J2, sol, 
    d, Dep, CT, T, epse, gamma, epsetrial, sigprojvoigth, proj, asol, 
    dadsigg, THWR, Rot, xitrial, xisol, xi, beta, rho, sigma, 
    rhotrial, Ce, pt, vec, betasol, young, G, K, epstint, epspint},
   
   Ce = N[{{(4 G)/3 + K, -((2 G)/3) + K, -((2 G)/3) + K, 0, 0, 
        0}, {-((2 G)/3) + K, (4 G)/3 + K, -((2 G)/3) + K, 0, 0, 
        0}, {-((2 G)/3) + K, -((2 G)/3) + K, (4 G)/3 + K, 0, 0, 
        0}, {0, 0, 0, G, 0, 0}, {0, 0, 0, 0, G, 0}, {0, 0, 0, 0, 0, 
        G}}] //. \!\(\*
TagBox["subst2",
Function[BoxForm`e$, 
MatrixForm[BoxForm`e$]]]\);
   invCe = 
    N[{{(G + 3 K)/(9 G K), -(1/(6 G)) + 1/(9 K), -(1/(6 G)) + 1/(9 K),
         0, 0, 0}, {-(1/(6 G)) + 1/(9 K), (G + 3 K)/(
        9 G K), -(1/(6 G)) + 1/(9 K), 0, 0, 
        0}, {-(1/(6 G)) + 1/(9 K), -(1/(6 G)) + 1/(9 K), (G + 3 K)/(
        9 G K), 0, 0, 0}, {0, 0, 0, 1/G, 0, 0}, {0, 0, 0, 0, 1/G, 
        0}, {0, 0, 0, 0, 0, 1/G}}] //. subst2;
   
   epstint = {epst[[1]], epst[[2]], 0, 0, 0, epst[[3]]} // N;
   epspint = {epsp[[1]], epsp[[2]], 0, 0, 0, epsp[[3]]} // N;
   
   epsetrial = (epstint - epspint);
   
   sigma = Ce.epsetrial;
   
   I1 = ComputeI1[sigma];
   J2 = ComputeJ2[sigma];
   yield = FDP[I1, J2] //. subst2;
   
   If[yield < 0,
    sigprojvoigth = sigma;
    epse = epsetrial;
    Dep = Ce;
    gamma = 0;
    ,
    
    xitrial = I1/Sqrt[3];
    rhotrial = Sqrt[2 J2];
    
    (*Auto valores em ordem decrescente*)
    {pt, vec} = EigenSystem[sigma] // N;
    
    betasol = 
     ArcTan[(Sqrt[3] (-sig2 + sig3))/(-2 sig1 + sig2 + sig3)] //. 
       subst2 /. {sig1 -> pt[[1]], sig2 -> pt[[2]], sig3 -> pt[[3]]};
    xisol = xitrial;
    proj = HW[F1HWCylVonMises[{xisol, rho, betasol}]] //. subst2;
    sigprojvoigth = 
     FromCartToVoigt[
      Sum[proj[[i]] Outer[Times, vec[[i]], vec[[i]]], {i, 1, 3}]];
    asol = ax[sigprojvoigth] //. subst2;
    (*dadsigg=dadsigmax[sigprojvoigth]//.subst2;*)
    epse = invCe.sigprojvoigth;
    gamma = Norm[epsetrial - epse]/Norm[asol];
    
    (*dadsigg=dadsigmax[sigma]//.subst2;
    CT=Ce.((IdentityMatrix[6]-(Outer[Times,asol,
    asol].Ce)/(asol.Ce.asol)));
    T=(IdentityMatrix[6]- gamma dadsigg.Ce );
    Dep=CT.T;*)
    
    dadsigg = dadsigmax[sigprojvoigth] //. subst2;
    Q = (IdentityMatrix[6] + gamma Ce.dadsigg);
    invQ = Inverse[Q];
    R = invQ.Ce;
    Dep = R - 1/(asol.R.asol) Outer[Times, R.asol, R.asol];
    
    ];
   
   Dep2D = {{Dep[[1, 1]], Dep[[1, 2]], Dep[[1, 6]]}, {Dep[[2, 1]], 
      Dep[[2, 2]], Dep[[2, 6]]}, {Dep[[6, 1]], Dep[[6, 2]], 
      Dep[[6, 6]]}};
   sigproj2D = {sigprojvoigth[[1]], sigprojvoigth[[2]], 
     sigprojvoigth[[6]]};
   {sx, sy, tauxy} = sigproj2D;
   sz = nu (sx + sy);
   ex = 1/young (sx - nu (sy + sz));
   ey = 1/young (sy - nu (sx + sz));
   exy = tauxy/(G);
   epse2D = {ex, ey, exy};
   {sigproj2D, Dep2D, epse2D, gamma} //. subst2
   
   ];
(*Compute2DShape*)
Compute2DShape[order_, eltype_] := 
  Block[{zeta1, zeta2, zeta3, a, b, xi, eta, psis, dpsis},
   If[serendipity == True,
    psis = {
       (1 - xi) (1 - eta) (-xi - eta - 1)/
         4,(*1*)(1 + xi) (1 - eta) (xi - eta - 1)/
         4,(*2*)(1 + xi) (1 + eta) (xi + eta - 1)/
         4,(*3*)(1 - xi) (1 + eta) (-xi + eta - 1)/4,(*4*)
       (1 - xi^2) (1 - eta)/2,(*5*)(1 + xi) (1 - eta^2)/
         2,(*6*)(1 - xi^2) (1 + eta)/2,(*7*)(1 - xi) (1 - eta^2)/
         2(*8*)
       };
    ,
    psis = {
       xi eta (xi - 1) (eta - 1)/4, xi eta (xi + 1) (eta - 1)/4, 
       xi eta (xi + 1) (eta + 1)/4, 
       xi eta (xi - 1) (eta + 1)/4, -eta (xi + 1) (xi - 1) (eta - 1)/2,
       -xi (xi + 1) (eta + 1) (eta - 1)/
         2, -eta (xi + 1) (xi - 1) (eta + 1)/
         2, -xi (xi - 1) (eta + 1) (eta - 1)/
         2, (xi + 1) (xi - 1) (eta + 1) (eta - 1)
       };
    ];
   dpsis = 
    Transpose[
     Table[{D[psis[[i]], xi], D[psis[[i]], eta]}, {i, 1, 
       Length[psis]}]];
   {psis, dpsis}
   ];
(****************************************************************************************)\

(*IntegrationRule*)
<< NumericalDifferentialEquationAnalysis`
IntegrationRule[porder_, eltype_] := Block[{pts, w, npts, matpsts},
   {pts, w} = Transpose[GaussianQuadratureWeights[porder + 2, -1, 1]];
   npts = Length[pts];
   matpsts = 
    Flatten[Table[{pts[[j]], pts[[i]], w[[j]] w[[i]]}, {i, npts, 
       1, -1}, {j, 1, npts}], 1];
   N[matpsts]
   ];
(****************************************************************************************)\

(*CalcStiff*)
Assemble[allcoords_, nnodes_, topol_, order_, eltype_, 
   displacement_] := 
  Block[{nels, rows, sz, cols, Kglob, Fglob, co, Ke, Fe, fu, rowglob, 
    colglob, uglob},
   nels = Length[allcoords];
   rows = Length[allcoords[[1]]];
   sz = 2 Length[nnodes];
   cols = rows;
   Kglob = Table[0, {sz}, {sz}];
   Fglob = Table[0, {sz}];
   uglob = 
    Table[Table[{displacement[[2 topol[[k, j]] - 1]], 
       displacement[[2 topol[[k, j]] ]]}, {j, 1, 
       Length[topol[[k]]]}], {k, 1, nels}];
   
   Table[
    co = allcoords[[k]] // N;
    {Ke, Fe} = CalcStiff[order, co, eltype, uglob[[k]]];
    fu = -1;
    Table[
     rowglob = topol[[k, i]];
     Table[
      colglob = topol[[k, j]];
      Kglob[[2 rowglob + fu, 2 colglob + fu]] += 
       Ke[[2 i + fu, 2 j + fu]];
      Kglob[[2 rowglob + fu, 2 colglob + 1 + fu]] += 
       Ke[[2 i + fu, 2 j + 1 + fu]];
      Kglob[[2 rowglob + 1 + fu, 2 colglob + fu]] += 
       Ke[[2 i + 1 + fu, 2 j + fu]];
      Kglob[[2 rowglob + 1 + fu, 2 colglob + 1 + fu]] += 
       Ke[[2 i + 1 + fu, 2 j + 1 + fu]];, {j, 1, cols}];
     Fglob[[2 rowglob + fu]] += Fe[[2 i + fu]];
     Fglob[[2 rowglob]] += Fe[[2 i]];
     , {i, 1, rows}];
    , {k, 1, nels}];
   
   {Kglob, Fglob}
   ];
(*Compute one dimension shape functions*)
ComputeShape[order_, var_, x0_, xf_] := Block[{npoints},
  npoints = order + 1;
  tab3[i_, n_] := Table[If[j == i, 1, 0], {j, 1, n}];
  poli3[j_, n_] := 
   Table[{x0 + (xf - x0) (i - 1)/(n - 1), tab3[j, n][[i]]}, {i, 1, n}];
  ListPoli[n_] := 
   Table[InterpolatingPolynomial[poli3[i, n], var], {i, 1, n}];
  ListPoli[npoints]
  ]
(*Find node id*)
FindIds[nodes_, coords_] := 
  Block[{nodestofind = Nearest[nodes, coords][[All, 1]]}, 
   Flatten[Position[nodes, Alternatives @@ nodestofind]]];
(*Find node id*)
LineTopology[ids_, order_] := Block[{k, vg, v, j, i},
   k = 0;
   vg = {};
   For[j = 1, j < Length[ids]/(order), j++,
    v = {};
    For[i = 1, i <= order + 1, i++,
     AppendTo[v, ids[[i + k]]];
     ];
    AppendTo[vg, v];
    k += order;
    ];
   vg
   ];
ContributeLineDirichlet[EK_, EF_, ids_, {dir_, val_}] := 
  Block[{nodes, i, j, k, Ek = EK, Ef = EF},
   nodes = Length[ids];
   For[i = 1, i <= nodes, i++,
    If[dir == 1,
      For[j = 1, j <= Length[Ek], j++,
       Ek[[2 ids[[i]] - 1, j]] = 0;
       Ek[[j, 2 ids[[i]] - 1]] = 0;
       ];
      Ek[[2 ids[[i]] - 1, 2 ids[[i]] - 1]] = 1;
      Ef[[2 ids[[i]] - 1]] = val;
      ,
      For[j = 1, j <= Length[Ek], j++,
       Ek[[2 ids[[i]], j]] = 0;
       Ek[[j, 2 ids[[i]]]] = 0;
       ];
      Ek[[2 ids[[i]], 2 ids[[i]]]] = 1;
      Ef[[2 ids[[i]]]] = val;
      ];
    ];
   {Ek, Ef}
   ];
ContributeStraigthLineNewman[nodes_, order_, ids_, normal_, f_] := 
  Block[{vecint, Ef, top, i, pt, xf, x, shapes, integral, deltas, 
    lengths},
   vecint = {};
   Ef = Table[0, {Length[nodes] 2}];
   top = LineTopology[ids, order];
   deltas = 
    Table[Table[
      Norm[nodes[[top[[i, j]]]] - nodes[[top[[i, j + 1]]]]], {j, 1, 
       order}], {i, 1, Length[top]}];
   If[order > 1,
    lengths = 
      Table[deltas[[i, j]] + deltas[[i, j + 1]], {j, 1, 
         order - 1}, {i, 1, Length[deltas]}][[1]];
    ,
    lengths = Flatten[deltas, 1];
    ];
   For[i = 1, i <= Length[lengths], i++,
    xf = lengths[[i]];
    shapes = ComputeShape[order, x, 0, xf];
    integral = 
     Table[Integrate[shapes[[i]] f[x], {x, 0, xf}], {i, 1, 
       Length[shapes]}];
    Table[
     pt = nodes[[top[[i, j]]]];
     Ef[[top[[i, j]] 2 - 1]] += integral[[j]] normal[[1]];
     Ef[[top[[i, j]] 2]] += integral[[j]] normal[[2]];
     ,
     {j, 1, order + 1}
     ];
    ];
   Ef
   ];

(*Compute a unitary normal vector wrt a circle o radius R*)
ComputeNormals[pt_, R_] := Block[{lines, x, normal, v, delta = 10^-9},
   rr[x_] = -(x/Sqrt[R^2 - (1 - delta) x^2]);
   pervec[v_] := {-(v[[2]]/Norm[v]), v[[1]]/Norm[v]};
   lines = rr[pt[[1]]] (x - pt[[1]]) + pt[[2]];
   normal = ({pt[[1]] + delta, 
        lines /. x -> pt[[1]] + delta} - {pt[[1]], 
        lines /. x -> pt[[1]]})/
     Norm[({pt[[1]] + delta, 
         lines /. x -> pt[[1]] + delta} - {pt[[1]], 
         lines /. x -> pt[[1]]})];
   pervec[normal]
   ];
(*Compute the force vector in a circle*)
ContributeLineNewmanPressure[nodes_, order_, ids_, R_, f_] := 
  Block[{vecint, Ef, top, i, pt, xf, x, shapes, normal, integral, 
    deltas, lengths},
   vecint = {};
   Ef = Table[0, {Length[nodes] 2}];
   top = LineTopology[ids, order];
   deltas = 
    Table[Table[
      Norm[nodes[[top[[i, j]]]] - nodes[[top[[i, j + 1]]]]], {j, 1, 
       order}], {i, 1, Length[top]}];
   If[order > 1,
    lengths = 
      Table[deltas[[i, j]] + deltas[[i, j + 1]], {j, 1, 
         order - 1}, {i, 1, Length[deltas]}][[1]];
    ,
    lengths = Flatten[deltas, 1];
    ];
   For[i = 1, i <= Length[lengths], i++,
    xf = lengths[[i]];
    shapes = ComputeShape[order, x, 0, xf];
    integral = 
     Table[Integrate[shapes[[i]] f[x], {x, 0, xf}], {i, 1, 
       Length[shapes]}];
    Table[
     pt = nodes[[top[[i, j]]]];
     normal = ComputeNormals[pt, R];
     Ef[[top[[i, j]] 2 - 1]] += integral[[j]] normal[[1]];
     Ef[[top[[i, j]] 2]] += integral[[j]] normal[[2]];
     ,
     {j, 1, order + 1}
     ];
    ];
   Ef
   ];

CoumpteStrain[gradprevsol_] := 
 Block[{dudx, dudy, dvdx, dvdy, gradu, strain, ex, ey, exy, ux, uy, 
   kk},
  {{dudx, dudy}, {dvdx, dvdy}} = gradprevsol;
  ex = dudx;
  ey = dvdy;
  exy = (dudy + dvdx);
  {ex, ey, exy}
  ]

(*Compute the integration point contribution of the integral*)
Contribute[data_] := 
  Block[{NShapes, gamma, psis, GradPsi, Jac, x, y, nnodes, GradPhi, 
    DetJ, InvJac, BB, C, ek, ef, elcoords, weight, stress, Dep, 
    eldisplacement, gradu, epst, epsp, epse, epspeint},
   {psis, GradPsi, elcoords, weight, eldisplacement} = data;
   {x, y} = psis.elcoords;
   Jac = GradPsi.elcoords;
   nnodes = Length[psis];
   DetJ = Det[Jac];
   InvJac = Inverse[Jac];
   GradPhi = InvJac.GradPsi;
   BB = {Flatten[Table[{GradPhi[[1, i]], 0}, {i, 1, nnodes}], 1], 
     Flatten[Table[{0, GradPhi[[2, i]]}, {i, 1, nnodes}], 1], 
     Flatten[Table[{GradPhi[[2, i]], GradPhi[[1, i]]}, {i, 1, 
        nnodes}], 1]};
   NShapes = {Flatten[Table[{psis[[i]], 0}, {i, 1, Length[psis]}], 1],
      Flatten[Table[{0, psis[[i]]}, {i, 1, Length[psis]}], 1]};
   (*Displacement gradient*)
   gradu = GradPhi.eldisplacement;
   (*Infinitesimal Strain Tensor*)
   epst = CoumpteStrain[gradu];
   (* globalcounter =  integration point index mesh identifier. 
   It has the size of the integration points rule multiplied by the \
number of mesh elements.*)
   (* Plastic strain vector in the last converged step. 
   This vector is updated when the newton method converge.  If[
   Converge=True, epspsolitern = epspvec] *)
   epsp = epspsolitern[[globalcounter]];
   (*Integration of the elastoplastic equations*)
   {stress, Dep, epse, gamma} = 
    ApplyStrainComputeSigmaDep[epst, epsp, subst2];
   epspeint = epst - epse;
   (*Store the plastic strain at the current integration point. 
   When newton's method converge the values are transfered to \
epspsolitern=epspvec. *)
   epspvec[[globalcounter]] = epspeint;
   globalcounter++;
   (*Element Stiffness Matrix contribution*)
   ek = (Transpose[BB].Dep.BB) weight DetJ;
   (*Element Internal force vector contribution*)
   ef = (Transpose[BB].stress - 
       Transpose[NShapes].{0, -bodyforce}) weight DetJ;
   {ek, ef}
   ];

(*CalcStiff - Assemble the element stiffness matrix and internal \
force vectors*)
CalcStiff[order_, elcoords_, eltype_, eldisplacement_] := 
  Block[{nnodes, ek, ef, intrule, psis, GradPsi, xi, eta, data, w, 
    npts},
   
   nnodes = Length[elcoords];
   ek = Table[0, {nnodes 2}, {nnodes 2}];
   ef = Table[0, {nnodes 2}];
   intrule = IntegrationRule[order, eltype];
   {psis, GradPsi} = Compute2DShape[order, eltype];
   npts = Length[intrule];
   Table[
    {xi, eta, w} = intrule[[i]];
    data = {psis, GradPsi, elcoords, w, eldisplacement};
    {ek, ef} += Contribute[data];
    , {i, 1, npts}
    ];
   {ek, ef}
   ];

ComputeSolNoInterpolation[topol_, coords_, order_, coefs_, eltype_, 
  scale_] := 
 Block[{elvecnorm, diplacenormvec, cx, cy, ux, uy, , displacevec, 
   elvec, X, InvJ, GradPhi, GradPsi, nels, dsol, xa, xb, k = 0, i, 
   phi, sol, phisz, j, xx, J, co, h, x = 0, psis, id, y = 0, xi, eta, 
   Jac, DetJac, kk},
  {psis, GradPsi} = Compute2DShape[order, eltype];
  nels = Length[topol];
  displacevec = {};
  diplacenormvec = {};
  Table[
   elvec = {};
   elvecnorm = {};
   x = 0.;
   y = 0.;
   kk = Length[psis];
   Table[
    id = topol[[i, j]];
    cx = coords[[id, 1]] ;
    cy = coords[[id, 2]] ;
    ux = scale coefs[[2 id - 1]] ;
     uy = scale coefs[[2 id]] ;
    AppendTo[elvec, {{cx, cy}, {ux + cx, uy + cy}}];
    AppendTo[elvecnorm, {cx, cy, Norm[{ux, uy}]}];
    , {j, 1, kk}];
   AppendTo[displacevec, elvec];
   AppendTo[diplacenormvec, elvec];
   , {i, 1, nels}];
  {displacevec, diplacenormvec}
  ]

GenerateGridMesh[R0_, RE_, nx_, ny_, order_] := 
 Block[{x = 0., y = 0., dx, dy, meshnodes, i, j, meshtopology = {}, 
   allcoords, k, l},
  meshnodes = {};
  k = 0;
  
  (*meshnodes=Flatten[Table[Table[{R Cos[\[Theta]],
  R Sin[\[Theta]]},{R,R0,RE,(RE-R0)/(nx order-2)}],{\[Theta],0,Pi/2,
  Pi/2 /(ny order-2)}],1]//N;*)
  r = (RE/R0)^(1/(-2 + nx order));
  meshnodes = 
   Flatten[Table[
      Table[{ R0 r^(n - 1) Cos[\[Theta]], 
        R0 r^(n - 1) Sin[\[Theta]]}, {n, 1., 
        nx order - 1}], {\[Theta], 0, Pi/2, Pi/2 /(ny order - 2)}], 
     1] // N;
  k = 0;
  For[i = 1 , i < ny, i++,
   l = 1;
   For[j = 1, j < nx, j++,
    (*AppendTo[meshtopology,{j+k,j+2+k,4 nx+j+k,4 nx-2+j+k,j+1+k,j+1+
    nx 2+k,j+nx 4-1+k,2 nx+ j-1+k,2 nx+ j+k}];*)
    AppendTo[
     meshtopology, {l + k, l + 2 + k, 4 nx + l + k, 4 nx - 2 + l + k, 
      l + 1 + k, l + 1 + nx 2 + k, l + nx 4 - 1 + k, 2 nx + l - 1 + k,
       2 nx + l + k}];
    l += 2;
    ];
   k += 4 nx - 2;
   ];
  If[order == 2,
   allcoords = 
     Table[meshnodes[[meshtopology[[i, j]]]], {i, 1, 
       Length[meshtopology]}, {j, 1, 9}];
   ,
   allcoords = 
     Table[meshnodes[[meshtopology[[i, j]]]], {i, 1, 
       Length[meshtopology]}, {j, 1, 4}];
   ];
  {allcoords, meshnodes, meshtopology}
  ]
GenerateGraphics[nodes_, topology_, order_] := 
  Block[{meshvis, nodevis},
   If[order == 2,
    meshvis = 
      Graphics[{FaceForm[], EdgeForm[Blue], 
        GraphicsComplex[nodes, 
         Polygon[topology[[All, {1, 5, 2, 6, 3, 7, 4, 8}]]]]}];
    ,
    meshvis = 
      Graphics[{FaceForm[], EdgeForm[Blue], 
        GraphicsComplex[nodes, 
         Polygon[topology[[All, {1, 2, 3, 4}]]]]}];
    ];
   nodevis = 
    Graphics[{MapIndexed[Text[#2[[1]], #1, {-1, 1}] &, nodes], {Blue, 
       Point[nodes]}}];
   {meshvis, nodevis}
   ];
interpolatingQuadBezierCurve[pts_List] /; Length[pts] == 3 := 
  BezierCurve[{pts[[1]], 1/2 (-pts[[1]] + 4 pts[[2]] - pts[[3]]), 
    pts[[3]]}];
interpolatingQuadBezierCurve[ptslist_List] := 
  interpolatingQuadBezierCurve /@ ptslist;
interpolatingQuadBezierCurveComplex[coords_, indices_] := 
 interpolatingQuadBezierCurve[Map[coords[[#]] &, indices]]
GenerateGraphics[nodes_, topology_] := Block[{meshvis, nodevis},
  nodevis = 
   Graphics[{MapIndexed[
      Style[Text[#2[[1]], #1, {-1.8, 1.8}], FontSize -> 12] &, 
      nodes], {PointSize[Large], Black, Point[nodes]}}];
  Show[nodevis]]
DefineLinePath[pt0_, ptf_, n_] := 
  Block[{dy, cx0, cy0, cxf, cyf, R, RF, cx, cy, linecoords, deltax, 
    deltay},
   
   
   {cx0, cy0} = pt0;
   {cxf, cyf} = ptf;
   
   RF = Sqrt[cxf^2 + cyf^2];
   R = Sqrt[cx0^2 + cy0^2];
   Print[RF];
   cx = cx0;
   cy = cy0;
   
   deltax = (cxf - cx0)/n;
   deltay = (cyf - cy0)/n;
   linecoords = {};
   Table[
    AppendTo[linecoords, {cx, cy}];
    cx += deltax;
    cy += deltay;
    , {i, 1, n + 1}];
   linecoords
   ];

order = 2;
serendipity = False;
{allcoords, nnodes, topol} = GenerateGridMesh[100, 200, 5, 4, order];
linestopology = Flatten[Table[
    {{topol[[i]][[1]], topol[[i]][[5]], topol[[i]][[2]]},
     {topol[[i]][[2]], topol[[i]][[6]], topol[[i]][[3]]},
     {topol[[i]][[3]], topol[[i]][[7]], topol[[i]][[4]]},
     {topol[[i]][[4]], topol[[i]][[8]], topol[[i]][[1]]}
     }, {i, 1, Length[topol]}], 1];
Show[GenerateGraphics[nnodes, topol], 
 Graphics[interpolatingQuadBezierCurveComplex[nnodes, linestopology]],
  ImageSize -> Automatic]
x0 = 100; xf = 200.;
y0 = 0; yf = 0;
ndivs = 100;
searchpathinferiorline = 
  Flatten[Table[{x, y}, {x, x0, xf, (xf - x0)/ndivs}, {y, y0, 
     yf, (yf - y0)/ndivs}], 1];
x0 = 0; xf = 0.;
y0 = 100; yf = 200;
searchpathleftline = Table[{x0, y}, {y, y0, yf, (yf - y0)/ndivs}];
theta0 = 0;
thetaf = Pi/2;
r = 100.;
searchpathinteriorhole = 
  Table[{r Cos[theta], r Sin[theta]}, {theta, theta0, 
    thetaf, (thetaf - theta0)/ndivs}];
idsinferior = FindIds[nnodes, searchpathinferiorline];
idsleft = FindIds[nnodes, searchpathleftline];
idshole = FindIds[nnodes, searchpathinteriorhole];


planestress = False;
bodyforce = 0;
ff = 0.19209;
f[x_] := ff;
fac = {0.1/0.19209, 0.14/0.19209, 0.18/0.19209, 0.19/0.19209, 
  0.19209/0.19209}
FEXT = ContributeLineNewmanPressure[nnodes, order, idshole, r, f];
eltype = 1;
order = 2;
subst2 = {young -> 210, sigy -> 0.24, nu -> 0.3, 
   G -> young/(2 (1 + nu)), K -> (young)/(3 (1 - 2 nu))};
globalcounter = 1;
intrule = IntegrationRule[order, eltype];
npts = Length[intrule]; 
nglobalpts = Length[topol] npts;
epspvec = Table[0, {nglobalpts}, {3}];
epspsolitern = Table[0, {nglobalpts}, {3}];
converge1 = {};
converge2 = {};
epspsolu = {};
stresssolu = {};
sol = {};
solss = {};
sol2 = {};
sol3 = {};
steps = 10;
factor = 1/steps;
displace = Table[0, {Length[nnodes] 2}];

lamb = 1;
diff = 10;
l = 1;
counterout = 1;
While[Abs[diff] > 10^-6 && counterout <= 30,
  diverge = False;
  convergevec1 = {};
  convergevec2 = {};
  Print["i = ", counterout, " | lamb = ", lamb, " | lambn = ", lambn, 
   " | diff = ", diff];
  counter = 1;
  err1 = 10;
  err2 = 10;
  temp = 100;
  tol = 10^-6;
  dw = Table[0, {Length[nnodes] 2}];
  
  lambn = lamb;
  While[counter <= 30 && err2 > tol,
   
   epsppost = {};
   stressppost = {};
   globalcounter = 1;
   {KT, FINT} = 
    Assemble[allcoords, nnodes, topol, order, eltype, displace];
   imposex = 1;
   imposey = 2;
   
   R = lamb  FEXT - FINT;
   {KT, R} = ContributeLineDirichlet[KT, R, idsinferior, {imposey, 0}];
   {KT, R} = ContributeLineDirichlet[KT, R, idsleft, {imposex, 0}];
   dws = LinearSolve[KT, R, Method -> "Banded"];
   dwb = LinearSolve[KT, FEXT, Method -> "Banded"];
   a = dwb.dwb;
   b = 2 (dw + dws).dwb;
   c = (dw + dws).(dw + dws) - l^2;
   dlamb = Solve[a x^2 + b x + c == 0, x][[2, 1, 2]];
   dww = dws + dlamb dwb;
   dw += dww;
   lamb += dlamb;
   (*dw=LinearSolve[KT,R];*)
   res = Norm[dww];
   displace += dww;
   err1 = Norm[R]/Norm[lamb  FEXT];
   (*If[err1>temp && counter>4,diverge=True];*)
   temp = err1;
   err2 = Norm[dww]/Norm[displace];
   AppendTo[convergevec1, {counter, err2}];
   AppendTo[convergevec2, {counter, err1}];
   Print["Iteration number = " , counter, "  |R|/|FE| =  ", 
    Norm[R]/Norm[factor FEXT], "  |\[CapitalDelta]u|/|u| = ", 
    Norm[dww]/Norm[displace], "  |R| =  ", Norm[R] , " |dw| = ", 
    Norm[dww], " | dlamb = ", dlamb, " | lamb = ", lamb];
   counter++;
   ];
  diff = Abs[lamb - lambn];
  AppendTo[stresssolu, stressppost];
  AppendTo[epspsolu, epsppost];
  AppendTo[solss, displace];
  
  AppendTo[converge1, convergevec1];
  AppendTo[converge2, convergevec2];
  AppendTo[sol, displace];
  id = FindIds[nnodes, {{200, 0}}][[1]];
  AppendTo[sol2, {displace[[id 2 - 1]], ff lamb}];
  
  (*AppendTo[sol2,{displace[[9 2-1]], ff fac[[i]]}];*)
  AppendTo[sol3, epspvec];
  factor += 1/steps;
  (*Atualiza variável de estado plástica no passo convergido*)
  epspsolitern = epspvec;
  counterout++;
  ];

data = Table[i, {i, 0, 0.192, 0.001}];
Clear[f]
eq[P_] := (Log[c/a] + 0.5 (1 - c^2/b^2)) - P/Y;
ub0[P_] := 2 P b/(young (b^2/a^2 - 1)) (1 - nu^2);
ub1[c_] := Y c^2 (1 - nu^2)/(young b);
Clear[a, b, c, nu, sigy, young]
subst = {Y -> 2 sigy/Sqrt[3], young -> 210, b -> 200, a -> 100, 
   sigy -> 0.240, nu -> 0.3};
P0 = Y/2 (1 - a^2 /b^2) //. subst;
f[P_] := Block[{},
  eqc = eq[P] //. subst;
  solc = FindRoot[eqc, {c, 0.2}][[1, 2]];
  solu = ub1[solc] //. subst;
  solu
  ]
computec[P_] := Block[{},
  eqc = eq[P] //. subst;
  solc = FindRoot[eqc, {c, 100}][[1, 2]]
  ]
ComputeAnalyticalStress[r_, P_] := 
 Block[{a = 100, b = 200, sigy = 0.24, sigr, sigt, cc, Y},
  Y = 2 sigy/Sqrt[3];
  cc = computec[P];
  If[a <= r <= cc,
   sigr = Y (-0.5 - Log[cc/r] + cc^2 /(2 b^2));
   sigt = Y (0.5 - Log[cc/r] + cc^2 /(2 b^2));
   ];
  If[cc <= r <= b,
   sigr = -Y cc^2 /(2 b^2) (b^2 / r^2 - 1);
   sigt = Y cc^2 /(2 b^2) (b^2 / r^2 + 1);
   ];
  {sigr, sigt}
  ]
u[P_] := If[P < P0, ub0[P], f[P]]
tab = Table[{u[data[[i]]] //. subst , data[[i]]}, {i, 1, 
    Length[data]}];
AppendTo[tab, {0.3, 0.19208}];
AppendTo[tab, {1.1, 0.19208}];
a = ListLinePlot[tab, PlotStyle -> {Black, Dashed}];
b = ListPlot[sol2, PlotMarkers -> {Automatic, 13}];
Show[a, b, PlotRange -> All, 
 PlotLegends -> 
  Placed[{"Analytical Solution", "Present Solution"}, {0.79, 0.11}], 
 Frame -> True, 
 FrameLabel -> {"radial displacement at outer face (mm)", 
   "Pressure (MPa)"}]

pack = Developer`ToPackedArray;

(*topol=pack@Transpose@Drop[Transpose@Import["https://www.dropbox.com/\
s/setx566dvgx3urx/mesh-els-strip-foot-structured4.txt?dl=1","Table"],\
1];
nnodesAll=Import["https://www.dropbox.com/s/mxelbdwug4yv3lr/mesh-\
nodes-strip-foot-structured4.txt?dl=1","Table"];*)
topol = pack@
   Transpose@
    Drop[Transpose@
      Import["https://www.dropbox.com/s/vtk5ybrgg69nl79/mesh-els-\
strip-foot-structured.txt?dl=1", "Table"], 1];
nnodesAll = 
  Import["https://www.dropbox.com/s/xu5f15vm4k0kmi1/mesh-nodes-strip-\
foot-structured.txt?dl=1", "Table"];
(*topol=pack@Transpose@Drop[Transpose@Import["https://www.dropbox.com/\
s/gz1rastmoemiaz0/mesh-els-strip-foot-structured-ninenode.txt?dl=1",\
"Table"],1];
nnodesAll=Import["https://www.dropbox.com/s/vaz8ljhr79hxpnt/mesh-\
nodes-strip-foot-structured-ninenode.txt?dl=1","Table"];*)

nnodes = pack@N[nnodesAll[[All, {2, 3}]]];
allcoords = 
  Table[nnodes[[topol[[i]][[j]]]], {i, 1, Length[topol]}, {j, 1, 8}];
(*edges are straight*)
meshVis1 = 
  Graphics[{FaceForm[], EdgeForm[Dashing[Tiny]], 
    GraphicsComplex[nnodes, Polygon[topol[[All, {1, 2, 3, 4}]]]]}];
meshVis1 = 
  Graphics[{FaceForm[], EdgeForm[Black], 
    GraphicsComplex[nnodes, Polygon[topol[[All, {1, 2, 3, 4}]]]]}];
nodeVis = 
  Graphics[{PointSize[Medium], Black, 
    MapIndexed[Text[#2[[1]], #1, {-1, 1}] &, nnodes], {Black, 
     Point[nnodes]}}];
nodeVis = Graphics[{PointSize[Medium], Black, {Black, Point[nnodes]}}];
Show[meshVis1];
el = 60;
nodeel = Table[nnodes[[topol[[el]][[i]]]], {i, 1, Length[topol[[el]]]}]
nodeVis = Graphics[{PointSize[Medium], Black, {Black, Point[nodeel]}}];
Show[meshVis1, nodeVis]
order = 2
serendipity = False;

a = 500;
b2 = 50;
x0 = 0.; xf = a;
y0 = 0; yf = 0;
ndivs = 10000;
searchpathinferiorline = 
  Flatten[Table[{x, y}, {x, x0, xf, (xf - x0)/ndivs}, {y, y0, 
     yf, (yf - y0)/ndivs}], 1];
x0 = 0; xf = 0.;
y0 = 0; yf = a;
searchpathleftline = Table[{x0, y}, {y, y0, yf, (yf - y0)/ndivs}];
x0 = 0; xf = b2;
y0 = a; yf = a;
searchpathupline = Table[{x, y0}, {x, x0, xf, (xf - x0)/ndivs}];
x0 = a; xf = a;
y0 = 0; yf = a;
searchpathrigthline = Table[{x0, y}, {y, y0, yf, (yf - y0)/ndivs}];
idsinferior = FindIds[nnodes, searchpathinferiorline]
idsleft = FindIds[nnodes, searchpathleftline]
idssup = FindIds[nnodes, searchpathupline]
idsrigth = FindIds[nnodes, searchpathrigthline]


planestress = False;
serendipity = True;
bodyforce = 0;
order = 2;
eltype = 1;


subst2 = {young -> 10000000., sigy -> 848.7, nu -> 0.48, 
   G -> young/(2 (1 + nu)), K -> (young)/(3 (1 - 2 nu))};


f[x_] := 2.97 sigy //. subst2 ;
FEXT = ContributeStraigthLineNewman[nnodes, order, idssup, {0, -1}, f];


globalcounter = 1;
intrule = IntegrationRule[order, eltype];
npts = Length[intrule]; 
nglobalpts = Length[topol] npts;
epspvec = Table[0, {nglobalpts}, {3}];
epspsolitern = Table[0, {nglobalpts}, {3}];

solss = {};
sol2 = {{0, 0}};
sol3 = {};
displace = Table[0, {Length[nnodes] 2}];
AppendTo[solss, displace];
epspsolu = {};
stresssolu = {};
dgammasol = {};

lamb = 1;
diff = 10;
l = 0.1;
counterout = 1;
tol1 = 10^-3;
tol2 = 10^-5;
While[Abs[diff] > tol1 && counterout <= 60,
 
 Print["i = ", counterout, " | lamb = ", lamb, " | lambn = ", lambn, 
  " | diff = ", diff];
 counter = 1;
 err1 = 10;
 err2 = 10;
 
 dw = Table[0, {Length[nnodes] 2}];
 
 lambn = lamb;
 While[counter <= 60 && err2 > tol2,
  
  epsppost = {};
  stressppost = {};
  globalcounter = 1;
  {KT, FINT} = 
   Assemble[allcoords, nnodes, topol, order, eltype, displace];
  imposex = 1;
  imposey = 2;
  
  R = lamb  FEXT - FINT;
  
  {KT, R} = ContributeLineDirichlet[KT, R, idsinferior, {imposey, 0}];
  {KT, R} = ContributeLineDirichlet[KT, R, idsleft, {imposex, 0}];
  {KT, R} = ContributeLineDirichlet[KT, R, idsrigth, {imposex, 0}];
  
  dws = LinearSolve[KT, R, Method -> "Banded"];
  dwb = LinearSolve[KT, FEXT, Method -> "Banded"];
  a = dwb.dwb;
  b = 2 (dw + dws).dwb;
  ccc = (dw + dws).(dw + dws) - l^2;
  dlamb = Solve[a x^2 + b x + ccc == 0, x][[2, 1, 2]];
  dww = dws + dlamb dwb;
  dw += dww;
  lamb += dlamb;
  (*dw=LinearSolve[KT,R];*)
  res = Norm[dww];
  displace += dww;
  err1 = Norm[R]/Norm[lamb  FEXT];
  (*If[err1>temp && counter>4,diverge=True];*)
  temp = err1;
  err2 = Norm[dww]/Norm[displace];
  AppendTo[convergevec1, {counter, err2}];
  AppendTo[convergevec2, {counter, err1}];
  Print["Iteration number = " , counter, "  |R|/|FE| =  ", 
   Norm[R]/Norm[factor FEXT], "  |\[CapitalDelta]u|/|u| = ", 
   Norm[dww]/Norm[displace], "  |R| =  ", Norm[R] , " |dw| = ", 
   Norm[dww], " | dlamb = ", dlamb, " | lamb = ", lamb];
  counter++;
  ];
 diff = Abs[lamb - lambn];
 cc = sigy/Sqrt[3] //. subst2;
 AppendTo[stresssolu, stressppost];
 AppendTo[epspsolu, epsppost];
 AppendTo[solss, displace];
 
 AppendTo[converge1, convergevec1];
 AppendTo[converge2, convergevec2];
 AppendTo[sol, displace];
 id = FindIds[nnodes, {{0, 500}}][[1]];
 AppendTo[sol2, {-displace[[id 2]]/100, f[x] lamb/cc}];
 
 (*AppendTo[sol2,{displace[[9 2-1]], ff fac[[i]]}];*)
 AppendTo[sol3, epspvec];
 factor += 1/steps;
 (*Atualiza variável de estado plástica no passo convergido*)
 epspsolitern = epspvec;
 counterout++;
 ]


sim = 5;
sol = solss[[sim]];
scale = 100;
deformed = (Flatten[nnodes] + scale sol);
tabdeformed = 
  Table[{deformed[[i]], deformed[[i + 1]]}, {i, 1, Length[deformed], 
    2}];
g = Show[meshVis1, 
  Graphics[{FaceForm[], EdgeForm[Black], 
    GraphicsComplex[tabdeformed, 
     Polygon[topol[[All, {1, 2, 3, 4}]]]]}]]
Show[ListLinePlot[(sol2 //. subst2), AspectRatio -> 1, 
  PlotMarkers -> {Automatic, 10}], Plot[(2. + Pi), {x, 0, 0.0035}], 
 PlotRange -> {{0, 0.0035}, {0, 6}}]
{vecs2, vecs3} = 
  ComputeSolNoInterpolation[topol, nnodes, order, sol, eltype, scale];
arrows = Table[
   Graphics[{Arrowheads[.012], 
     Arrow[{vecs2[[el]][[i]][[1]], vecs2[[el]][[i]][[2]]}]}], {el, 1, 
    Length[vecs2]}, {i, 1, Length[vecs2[[el]]]}];
sh = Show[meshVis1, arrows, PlotRange -> All]